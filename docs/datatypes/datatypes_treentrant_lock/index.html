<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>TReentrantLock · ZIO</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A TReentrantLock allows safe concurrent access to some mutable state efficiently, allowing multiple fibers to read the "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="TReentrantLock · ZIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.dev/"/><meta property="og:description" content="A TReentrantLock allows safe concurrent access to some mutable state efficiently, allowing multiple fibers to read the "/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/navbar_brand.png" alt="ZIO"/><h2 class="headerTitleWithLogo">ZIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/overview/overview_index" target="_self">Overview</a></li><li class=""><a href="/docs/datatypes/datatypes_index" target="_self">Data Types</a></li><li class=""><a href="/docs/interop/interop_index" target="_self">Interop</a></li><li class=""><a href="/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/docs/howto/howto_index" target="_self">How to</a></li><li class=""><a href="/docs/resources/resources" target="_self">Resources</a></li><li class=""><a href="/docs/ecosystem/ecosystem" target="_self">Ecosystem</a></li><li class=""><a href="/docs/about/about_index" target="_self">About</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">TReentrantLock</h1></header><article><div><span><p>A TReentrantLock allows safe concurrent access to some mutable state efficiently, allowing multiple fibers to read the
state (because that is safe to do) but only one fiber to modify the state (to prevent data corruption). Also, even though
the TReentrantLock is implemented using STM; reads and writes can be committed, allowing this to be used as a building
block for solutions that expose purely ZIO effects and internally allow locking on more than one piece of state in a
simple and composable way (thanks to STM).</p>
<p>A <code>TReentrantLock</code> is a <em>reentrant</em> read/write lock. A reentrant lock is one where a fiber can claim the lock multiple
times without blocking on itself. It's useful in situations where it's not easy to keep track of whether you have already
grabbed a lock. If a lock is non re-entrant you could grab the lock, then block when you go to grab it again, effectively
causing a deadlock.</p>
<h2><a class="anchor" aria-hidden="true" id="semantics"></a><a href="#semantics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Semantics</h2>
<p>This lock allows both readers and writers to reacquire read or write locks with reentrancy guarantees. Readers are not
allowed until all write locks held by the writing fiber have been released. Writers are not allowed unless there are no
other locks or the fiber wanting to hold a write lock already has a read lock and there are no other fibers holding a
read lock.</p>
<p>This lock also allows upgrading from a read lock to a write lock (automatically) and downgrading
from a write lock to a read lock (automatically provided that you upgraded from a read lock to a write lock).</p>
<h2><a class="anchor" aria-hidden="true" id="creating-a-reentrant-lock"></a><a href="#creating-a-reentrant-lock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a reentrant lock</h2>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.stm._

<span class="hljs-keyword">val</span> reentrantLock = <span class="hljs-type">TReentrantLock</span>.make
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="acquiring-a-read-lock"></a><a href="#acquiring-a-read-lock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acquiring a read lock</h2>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.stm._

<span class="hljs-keyword">val</span> program =
  (<span class="hljs-keyword">for</span> {
    lock &lt;- <span class="hljs-type">TReentrantLock</span>.make
    _    &lt;- lock.acquireRead
    rst  &lt;- lock.readLocked  <span class="hljs-comment">// lock is read-locked once transaction completes</span>
    wst  &lt;- lock.writeLocked <span class="hljs-comment">// lock is not write-locked</span>
  } <span class="hljs-keyword">yield</span> rst &amp;&amp; !wst).commit
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="acquiring-a-write-lock"></a><a href="#acquiring-a-write-lock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acquiring a write lock</h2>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.stm._

<span class="hljs-keyword">val</span> writeLockProgram: <span class="hljs-type">UIO</span>[<span class="hljs-type">Boolean</span>] =
  (<span class="hljs-keyword">for</span> {
    lock &lt;- <span class="hljs-type">TReentrantLock</span>.make
    _    &lt;- lock.acquireWrite
    wst  &lt;- lock.writeLocked <span class="hljs-comment">// lock is write-locked once transaction completes</span>
    rst  &lt;- lock.readLocked  <span class="hljs-comment">// lock is not read-locked</span>
  } <span class="hljs-keyword">yield</span> !rst &amp;&amp; wst).commit
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="multiple-fibers-can-hold-read-locks"></a><a href="#multiple-fibers-can-hold-read-locks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple fibers can hold read locks</h2>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.stm._

<span class="hljs-keyword">val</span> multipleReadLocksProgram: <span class="hljs-type">UIO</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-keyword">for</span> {
  lock          &lt;- <span class="hljs-type">TReentrantLock</span>.make.commit
  fiber0        &lt;- lock.acquireRead.commit.fork <span class="hljs-comment">// fiber0 acquires a read-lock</span>
  currentState1 &lt;- fiber0.join                  <span class="hljs-comment">// 1 read lock held</span>
  fiber1        &lt;- lock.acquireRead.commit.fork <span class="hljs-comment">// fiber1 acquires a read-lock</span>
  currentState2 &lt;- fiber1.join                  <span class="hljs-comment">// 2 read locks held </span>
} <span class="hljs-keyword">yield</span> (currentState1, currentState2)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="upgrading-and-downgrading-locks"></a><a href="#upgrading-and-downgrading-locks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Upgrading and downgrading locks</h2>
<p>If your fiber already has a read lock then it is possible to upgrade the lock to a write lock provided that no other
reader (other than your fiber) holds a lock</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.stm._

<span class="hljs-keyword">val</span> upgradeDowngradeProgram: <span class="hljs-type">UIO</span>[(<span class="hljs-type">Boolean</span>, <span class="hljs-type">Boolean</span>, <span class="hljs-type">Boolean</span>, <span class="hljs-type">Boolean</span>)] = <span class="hljs-keyword">for</span> {
  lock               &lt;- <span class="hljs-type">TReentrantLock</span>.make.commit
  _                  &lt;- lock.acquireRead.commit
  _                  &lt;- lock.acquireWrite.commit  <span class="hljs-comment">// upgrade</span>
  isWriteLocked      &lt;- lock.writeLocked.commit   <span class="hljs-comment">// now write-locked</span>
  isReadLocked       &lt;- lock.readLocked.commit    <span class="hljs-comment">// and read-locked</span>
  _                  &lt;- lock.releaseWrite.commit  <span class="hljs-comment">// downgrade</span>
  isWriteLockedAfter &lt;- lock.writeLocked.commit   <span class="hljs-comment">// no longer write-locked</span>
  isReadLockedAfter  &lt;- lock.readLocked.commit    <span class="hljs-comment">// still read-locked</span>
} <span class="hljs-keyword">yield</span> (isWriteLocked, isReadLocked, isWriteLockedAfter, isReadLockedAfter)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="acquiring-a-write-lock-in-a-contentious-scenario"></a><a href="#acquiring-a-write-lock-in-a-contentious-scenario" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acquiring a write lock in a contentious scenario</h2>
<p>A write lock can be acquired immediately only if one of the following conditions are satisfied:</p>
<ol>
<li>There are no other holders of the lock</li>
<li>The current fiber is already holding a read lock and there are no other parties holding a read lock</li>
</ol>
<p>If either of the above scenarios are untrue then attempting to acquire a write lock will semantically block the fiber.
Here is an example which demonstrates that a write lock can only be obtained by the fiber once all other readers (except
the fiber attempting to acquire the write lock) have released their hold on the (read or write) lock.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.clock._
<span class="hljs-keyword">import</span> zio.console._
<span class="hljs-keyword">import</span> zio.stm._
<span class="hljs-keyword">import</span> zio.duration._

<span class="hljs-keyword">val</span> writeLockDemoProgram: <span class="hljs-type">URIO</span>[<span class="hljs-type">Console</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Clock</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  l  &lt;- <span class="hljs-type">TReentrantLock</span>.make.commit
  _  &lt;- putStrLn(<span class="hljs-string">"Beginning test"</span>)
  f1 &lt;- (l.acquireRead.commit *&gt; <span class="hljs-type">ZIO</span>.sleep(<span class="hljs-number">5.</span>seconds) *&gt; l.releaseRead.commit).fork
  f2 &lt;- (l.acquireRead.commit *&gt; putStrLn(<span class="hljs-string">"read-lock"</span>) *&gt; l.acquireWrite.commit *&gt; putStrLn(<span class="hljs-string">"I have upgraded!"</span>)).fork
  _  &lt;- (f1 zip f2).join
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>Here fiber <code>f1</code> acquires a read lock and sleeps for 5 seconds before releasing it. Fiber <code>f2</code> also acquires a read
lock and immediately tries to acquire a write lock. However, <code>f2</code> will have to semantically block for approximately 5
seconds to obtain a write lock because <code>f1</code> will release its hold on the lock and only then can <code>f2</code> acquire a hold for
the write lock.</p>
<h2><a class="anchor" aria-hidden="true" id="safer-methods--readlock-and-writelock"></a><a href="#safer-methods--readlock-and-writelock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Safer methods  (<code>readLock</code> and <code>writeLock</code>)</h2>
<p>Using <code>acquireRead</code>, <code>acquireWrite</code>, <code>releaseRead</code> and <code>releaseWrite</code> should be avoided for simple use cases relying on
methods like <code>readLock</code> and <code>writeLock</code> instead. <code>readLock</code> and <code>writeLock</code> automatically acquire and release the lock
thanks to the <code>Managed</code> construct. The program described below is a safer version of the program above and ensures we
don't hold onto any resources once we are done using the reentrant lock.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.clock._
<span class="hljs-keyword">import</span> zio.console._
<span class="hljs-keyword">import</span> zio.stm._
<span class="hljs-keyword">import</span> zio.duration._

<span class="hljs-keyword">val</span> saferProgram: <span class="hljs-type">URIO</span>[<span class="hljs-type">Console</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Clock</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
  lock &lt;- <span class="hljs-type">TReentrantLock</span>.make.commit
  f1   &lt;- lock.readLock.use_(<span class="hljs-type">ZIO</span>.sleep(<span class="hljs-number">5.</span>seconds) *&gt; putStrLn(<span class="hljs-string">"Powering down"</span>)).fork
  f2   &lt;- lock.readLock.use_(lock.writeLock.use_(putStrLn(<span class="hljs-string">"Huzzah, writes are mine"</span>))).fork
  _    &lt;- (f1 zip f2).join
} <span class="hljs-keyword">yield</span> ()
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#semantics">Semantics</a></li><li><a href="#creating-a-reentrant-lock">Creating a reentrant lock</a></li><li><a href="#acquiring-a-read-lock">Acquiring a read lock</a></li><li><a href="#acquiring-a-write-lock">Acquiring a write lock</a></li><li><a href="#multiple-fibers-can-hold-read-locks">Multiple fibers can hold read locks</a></li><li><a href="#upgrading-and-downgrading-locks">Upgrading and downgrading locks</a></li><li><a href="#acquiring-a-write-lock-in-a-contentious-scenario">Acquiring a write lock in a contentious scenario</a></li><li><a href="#safer-methods--readlock-and-writelock">Safer methods  (<code>readLock</code> and <code>writeLock</code>)</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/navbar_brand.png" alt="ZIO"/></a><div><h5>GitHub</h5><a href="https://github.com/zio/zio"><img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github"/></a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="https://img.shields.io/discord/629491597070827530?logo=discord&amp;style=social" alt="discord"/></a></div><div><h5>Follow us on Twitter</h5><a href="https://twitter.com/zioscala"><img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&amp;style=social" alt="twitter"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of zio</a></div><div><a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify"/></a></div></section><section class="copyright">Copyright © 2020 ZIO Maintainers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0c94b59071da7001757d08ab43d9e033',
                indexName: 'zio',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>